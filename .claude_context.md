# Claude Code 工作上下文

## 任务概述
优化 AIO 实现，使批量请求或单请求完成后才唤醒协程，而不是 eventfd 触发就唤醒。

---

## 已完成的修改

### 1. `galay-kernel/kernel/Awaitable.h`

`FileReadAwaitable` 和 `FileWriteAwaitable` 新增字段（仅 `#ifdef USE_EPOLL`）：

```cpp
size_t m_expect_count;      ///< 期望完成的事件数量（默认1）
size_t m_finished_count{0}; ///< 已完成的事件数量
```

构造函数新增参数 `size_t expect_count = 1`。

### 2. `galay-kernel/kernel/EpollScheduler.cc`

`handleFileRead` 和 `handleFileWrite` 修改逻辑：

```cpp
void EpollScheduler::handleFileRead(IOController* controller)
{
    FileReadAwaitable* awaitable = static_cast<FileReadAwaitable*>(controller->m_awaitable);

    // 读取 eventfd 获取完成的事件数量
    uint64_t finish_count = 0;
    int ret = read(awaitable->m_event_fd, &finish_count, sizeof(finish_count));
    if (ret < 0) {
        if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
            return;  // 尚未就绪，等待下次通知
        }
        awaitable->m_result = std::unexpected(IOError(kReadFailed, static_cast<uint32_t>(errno)));
        epoll_ctl(m_epoll_fd, EPOLL_CTL_DEL, awaitable->m_event_fd, nullptr);
        awaitable->m_waker.wakeUp();
        return;
    }

    // 批量收割 AIO 事件
    std::vector<struct io_event> aio_events(finish_count);
    int num = io_getevents(awaitable->m_aio_ctx, finish_count, finish_count, aio_events.data(), nullptr);

    if (num > 0) {
        awaitable->m_finished_count += num;
        // 处理最后一个事件的结果
        long res = aio_events[num - 1].res;
        // ... 设置 m_result
    }

    // 所有事件完成才唤醒协程
    if (awaitable->m_finished_count >= awaitable->m_expect_count) {
        epoll_ctl(m_epoll_fd, EPOLL_CTL_DEL, awaitable->m_event_fd, nullptr);
        awaitable->m_waker.wakeUp();
    }
}
```

`handleFileWrite` 同理。

### 3. `galay-kernel/async/AsyncFile.cc`

添加头文件以获取平台宏：
```cpp
#include "galay-kernel/common/Defn.hpp"
```

### 4. `test/test_file_io.cc` (新建)

三个平台的文件 IO 测试：
- **Kqueue (macOS)**: `AsyncFile` 读写测试
- **Epoll (Linux libaio)**: `AioFile` 单次读取、批量读取(3个请求)、写入测试
- **io_uring (Linux)**: `AsyncFile` 读写测试

所有测试在单个协程中完成，使用 `std::atomic<bool>` 等待完成，不使用 `sleep_for`。

### 5. `test/CMakeLists.txt`

添加测试目标：
```cmake
add_executable(test_file_io test_file_io.cc)
target_link_libraries(test_file_io PRIVATE galay-kernel)
target_include_directories(test_file_io PRIVATE ${CMAKE_SOURCE_DIR})
```

---

## 测试状态

| 平台 | 状态 |
|------|------|
| Kqueue (macOS) | ✅ 通过 |
| Epoll (Linux libaio) | ⏳ 待测试 |
| io_uring (Linux) | ⏳ 待测试 |

---

## 编译运行命令

```bash
cd build
cmake ..
make test_file_io
./bin/test_file_io
```

---

## 已确认无需修改

1. **`IOUringScheduler::addAccept`**: `awaitable->m_host->addrLen()` 返回 `socklen_t*`，符合 `io_uring_prep_accept` 要求，无需修改。

2. **Kqueue `processEvent` 中 `FILEREAD`/`FILEWRITE`**: 事件唤醒是无条件的，不需要检查 `handleFileRead` 返回值。

---

## 关键文件位置

- `galay-kernel/kernel/Awaitable.h` - Awaitable 结构定义
- `galay-kernel/kernel/EpollScheduler.cc` - Epoll 调度器实现
- `galay-kernel/kernel/KqueueScheduler.cc` - Kqueue 调度器实现
- `galay-kernel/kernel/IOUringScheduler.cc` - io_uring 调度器实现
- `galay-kernel/async/AioFile.h/cc` - Epoll 平台 AIO 文件操作
- `galay-kernel/async/AsyncFile.h/cc` - Kqueue/io_uring 平台异步文件操作
- `galay-kernel/common/Defn.hpp` - 平台宏定义 (USE_KQUEUE/USE_EPOLL/USE_IOURING)

---

## 下一步

在 Linux 平台测试 Epoll (libaio) 和 io_uring 的文件 IO 功能。
